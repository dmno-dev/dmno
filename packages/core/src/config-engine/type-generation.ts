import fs from 'node:fs';
import _ from 'lodash-es';
import { getTsDefinitionForNode } from '@dmno/configraph';

import {
  DmnoService,
} from './config-engine';


const AUTOGENERATED_FILE_BANNER = `
// ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘
// ðŸ›‘ THIS IS AN AUTOGENERATED FILE - DO NOT EDIT DIRECTLY ðŸ›‘
// ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘ ðŸ›‘
`;

export async function generateServiceTypes(service: DmnoService, writeToFile = false) {
  if (!service.isSchemaValid) return;

  // TODO: this could switch between different type gen methods
  const dtsSrc = await generateTypescriptTypes(service);

  if (writeToFile) {
    const typeGenFolderPath = `${service.path}/.dmno/.typegen`;
    await fs.promises.mkdir(typeGenFolderPath, { recursive: true });

    // write schema.d.ts which has the config schema turned into TS in it
    await fs.promises.writeFile(`${typeGenFolderPath}/schema.d.ts`, dtsSrc, 'utf-8');

    // write global file which defines a DMNO_CONFIG global
    // this used in our config.mts files and in front-end apps where we inject rollup rewrites
    await fs.promises.writeFile(`${typeGenFolderPath}/global.d.ts`, `${AUTOGENERATED_FILE_BANNER}
import type { DmnoConfigSchema } from './schema.d.ts';

declare global {
  /** ${service.serviceName} config global obj */
  const DMNO_CONFIG: DmnoConfigSchema;
}
`, 'utf-8');

    // write global file which defines a DMNO_CONFIG global
    // this used in our config.mts files and in front-end apps where we inject rollup rewrites
    await fs.promises.writeFile(`${typeGenFolderPath}/global-public.d.ts`, `${AUTOGENERATED_FILE_BANNER}
import type { DmnoPublicConfigSchema } from './schema.d.ts';

declare global {
  /** ${service.serviceName} config global obj - public (non-sensitive) items only */
  const DMNO_PUBLIC_CONFIG: DmnoPublicConfigSchema;
}
`, 'utf-8');
  }
}

export async function generateTypescriptTypes(service: DmnoService) {
  const tsSrc = [
    AUTOGENERATED_FILE_BANNER,
    'export type FullDmnoConfigSchema = {',
  ];
  const dmnoConfigKeys: Array<string> = [];
  const dmnoPublicConfigKeys: Array<string> = [];
  for (const itemKey in service.config) {
    const configItem = service.config[itemKey];
    // generate the TS type for the item in the full schema
    tsSrc.push(...await getTsDefinitionForNode(configItem, 1));
    // then include in DMNO_CONFIG and DMNO_PUBLIC_CONFIG based on settings
    if (configItem.includeInDmnoConfig) {
      dmnoConfigKeys.push(itemKey);
      if (!configItem.isSensitive) dmnoPublicConfigKeys.push(itemKey);
    }
  }
  tsSrc.push('}');
  tsSrc.push('\n');


  const keysForPick = _.map(dmnoConfigKeys, JSON.stringify).join(' | ');
  tsSrc.push(`export type DmnoConfigSchema = Pick<FullDmnoConfigSchema, ${keysForPick || 'never'}>`);
  const publicKeysForPick = _.map(dmnoPublicConfigKeys, JSON.stringify).join(' | ');
  tsSrc.push(`export type DmnoPublicConfigSchema = Pick<FullDmnoConfigSchema, ${publicKeysForPick || 'never'}>`);
  return tsSrc.join('\n');
}
export async function getPublicConfigKeys(service: DmnoService) {
  const nonSecretItems = _.pickBy(service.config, (item, itemKey) => {
    return !item.isSensitive;
  });
  return _.keys(nonSecretItems);
}

