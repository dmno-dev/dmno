--- 
title: Astro
---

import TabbedCode from '@/components/TabbedCode.astro';
import BugReportLink from '@/components/BugReportLink.astro';

At DMNO we _love_ Astro (this very site is built with it). That's why we're very excited to make it easier (and safer) to use environment variables in all of your Astro apps, whether it's on the client or the server!

To get started install `dmno` and the `astro` plugin: 

<TabbedCode packageName="@dmno/astro-integration dmno" />

### Scaffold your DMNO config

Next, run the following command in a terminal at the root of your repo:

<TabbedCode command="dmno init" />

This will create a `.dmno` directory in the root of your project with a `config.mts` file. And it will also create `.dmno` folders and config files in each of the other directories for other apps/services if you have a monorepo.

### Configure your environment variables

See our [Schema Guide](/docs/guides/schema) for the specifics of how to write your first DMNO schema.

## Setup

### Install the dmno astro integration

Using astro's add command will automatically install dependencies and update your astro config.

<TabbedCode command="astro add @dmno/astro-integration" />

If you run into any issues, feel free to <BugReportLink label='integrations/astro'>report them to us on GitHub</BugReportLink> and try the manual installation steps below.

#### Manual install instructions

Install dmno itself and the astro integration
<TabbedCode packageName="@dmno/astro-integration dmno" />

Update your `astro.config.mjs` - import the plugin, and add to `defineConfig`: 

```diff lang="js" title="astro.config.mjs" ins="dmnoAstroIntegration()"
import { defineConfig } from 'astro/config';
+import dmnoAstroIntegration from '@dmno/astro-integration';

export default defineConfig({
  // ...
  integrations: [dmnoAstroIntegration()],
});
```

### Set up Typescript

Astro is built with TypeScript, and so is DMNO. This means that you get full type completion and intellisense for your config items. You just need to make sure the typescript compiler knows about them

By default, astro's generated tsconfig does not explicitly include any specific files, but to get DMNO_CONFIG autocompletion working everywhere, we'll have to specify the files we want to include, as well as reference the generated types.


```diff lang="json" title="tsconfig.json" ins={"You only need to add the file types you are using:": 4} ins={"Add your astro config file (with the correct file extension)": 12} ins={"Add references to dmno's autogenerated types)": 14}
{
  "extends": "astro/tsconfigs/strict",
+  "include": [

+    "src/**/*.astro",
+    "src/**/*.ts",
+    "src/**/*.js",
+    "src/**/*.d.ts",
+    "src/**/*.jsx",
+    "src/**/*.tsx",
+    "src/**/*.mdx",

+    "astro.config.mjs", 

+    "./.dmno/.typegen/global.d.ts",
+    "./.dmno/.typegen/global-public.d.ts",
+    "./.dmno/.typegen/node.d.ts"
+  ],
  // ...
}
```

After that, DMNO will automatically update your definitions as you add new items to your schema. ðŸŽ‰


## Accessing config

DMNO globally injects your config into your application. You can access it via:
- `DMNO_CONFIG` - includes _all_ of your config items
- `DMNO_PUBLIC_CONFIG` - includes only items not marked with `sensitive: true`

Which you can access (with full type-safety and autocompletion) in templates and code.

:::tip[Why globals?]
It's really no different than using `process.env` or `import.meta.env` - but by using our own variables, we can provide a more consistent experience and do some magic...
:::

Now in your application code you'll have access to a global object with all of your _public_ config items (those which aren't marked ) called `DMNO_PUBLIC_CONFIG`. 

```js
const mySecretItem = DMNO_CONFIG.SECRET_API_KEY;
const nonSecretItem = DMNO_PUBLIC_CONFIG.PUBLISHABLE_ITEM;
```

### Client vs Server/SSR/Security/etc 

In theory, you should only access `DMNO_PUBLIC_CONFIG` on the _client_, and you can access both `DMNO_CONFIG` and `DMNO_PUBLIC_CONFIG` on the server.

Sounds easy, right? Except in a world of hybrid client/server rendering and rehydration, and when you may actually need sensitive config during a server-side render, it can be hard to keep track of what is getting rendered where...

So we make it easy for you:

- In the browser/client, you only have access to `DMNO_PUBLIC_CONFIG` and if you try to access `DMNO_CONFIG`, we'll throw an error ðŸ›‘
- We also inject a middleware that detects any leaked secrets, just in case you leaked a secret into ANYTHING getting sent over the wire...


### Static vs dynamic config

DMNO gives you explicit control over how your config items are treated - whether they will be replaced into your bundled code at build time (static), or reloaded at boot time (dynamic). See the [dynamic config guide](/docs/guides/dynamic-config) for more details.

As for features related to dynamic config, this integration will:
- automatically inject the API route required to fetch public+dynamic config (if you have any in your schema)
- warn you if you accidentally use a dynamic config item during a pre-render - regardless of the [output mode](https://docs.astro.build/en/basics/rendering-modes/#server-output-modes) you are using

---

## Additional Recipes

### Using env vars within `astro.config.*`
It's often useful to be able to access configuration / env vars within your astro config.

Without DMNO, it's a bit awkward, but DMNO makes it dead simple - in fact it's already available!

Just reference config vars via `DMNO_CONFIG.SOME_ITEM` like you do everywhere else.

You'll get TS autocompletion as long as you've added your config file to the your `tsconfig.json`'s include list. If for some reason that doesn't work, you can also try adding a `///` reference at the top of the file.

### Injecting config into markdown files

Markdown files are processed by astro but treated as pure content without evaluating any javsascript. So if you need to inject any DMNO_CONFIG values, you'll need to use MDX instead.

See [@astrojs/mdx integration](https://docs.astro.build/en/guides/integrations-guide/mdx/)

Then you need to use JSX within your markdown content. For example:

```mdx
# Header with config item { DMNO_PUBLIC_CONFIG.SOME_VAR }
```

For links, you'll need to use the html/jsx version rather than a markdown style link:
```diff lang="mdx" ins={"ðŸ¥³ Use HTML/JSX style links": 1} del={"ðŸ¥µ Markdown style links dont work": 3}
+
+Join us on our <a href={DMNO_PUBLIC_CONFIG.DISCORD_JOIN_URL}>Discord</a>

-Join us on our [Discord](DMNO_PUBLIC_CONFIG.DISCORD_JOIN_URL)
-Join us on our [Discord]({DMNO_PUBLIC_CONFIG.DISCORD_JOIN_URL})
-Join us on our [Discord]({ DMNO_PUBLIC_CONFIG.DISCORD_JOIN_URL })


```


### Injecting config into inline script tags
Another case where astro may not process the code you write and inject DMNO_CONFIG is within the body of an inline script. Attributes do work though, so here is one workaround you can use:

**GoogleAnalytics.astro**
```diff lang="jsx"
<script
  type="text/partytown"
  async
-  src="https://www.googletagmanager.com/gtag/js?id=G-12345"
+  src=`https://www.googletagmanager.com/gtag/js?id=${DMNO_PUBLIC_CONFIG.GOOGLE_TAG_MANAGER_ID}`
></script>

<script
  type="text/partytown"
+  gtmid={DMNO_PUBLIC_CONFIG.GOOGLE_TAG_MANAGER_ID}
>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  // we can reference the attributes of the current script tag
-  gtag("config", "G-12345");
+  gtag("config", document.currentScript.getAttribute("gtmid"));
</script>
```

