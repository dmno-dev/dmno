---
title: Next.js
description: Using DMNO with Next.js
---

import TabbedCode from '@/components/TabbedCode.astro';

If you have an existing Next.js app, you're probably already familiar with how environment variables work in Next. Check their docs [here](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables) if you need a refresher. 

Now forget all of that, and let's simplify things with DMNO. ðŸ¤£

### Install dependencies

First, install the `@dmno/config-engine` and `@dmno/dmno-next` packages.

<TabbedCode packageName="@dmno/config-engine @dmno/next-integration" />

{/* TEMPLATE THIS? */}
### Scaffold your DMNO config

Run the following command in a terminal at the root of your repo:

<TabbedCode command="dmno init" />

This will create a `.dmno` directory in the root of your project with a `config.mts` file. And it will also create `.dmno` folders and config files in each of the other directories for other apps/services if you have a monorepo.


### Configure your environment variables    

See our [Schema Guide](/docs/guides/schema) for the specifics of how to write your first DMNO schema. 

### Add the plugin to your config

Finally, in your `next.config.js`, import the plugin, and add to following to `nextConfig`: 

```typescript
// ...
import { dmnoNextPlugin } from '@dmno/next-integration';

/** @type {import('next').NextConfig} */
const nextConfig = {
  // ... TBD
};

```

### Next.js specific features

If you're migrating from an existing Next.js app, you might have some environment variables that are specific to Next.js. For example, you might have a `NEXT_PUBLIC_` prefix for environment variables that are exposed to the browser.

DMNO makes all of this simpler in a few ways. 

First, in your schema, `sensitive` items won't be available in the `DMNO_PUBLIC_CONFIG` object that we expose globally for the browser. This effectively serves the same purpose as the `NEXT_PUBLIC_` prefix, without any of the renaming or potential duplication. 

Secondly, for the server side of things, we expose all config items via `process.dmnoEnv` which gives you full type completion and intellisense. Neither of which you got previously when using `process.env`.

Finally, if you try to access a variable that doesn't exist, you will get an actionable error message. Where previously with `process.env` you would have received no feedback at all. 

> INSERT SCREENSHOT/GIF

### Client/Server/SSR/SSG/RSC/WTF?

With the addition of the [Next.js App Router](https://nextjs.org/docs/app), the divide between client and server gets a bit harder to reason about. We recommend Josh's excellent [article](https://www.joshwcomeau.com/react/server-components/) if you're trying to wrap your head around it. 

Basically, you should follow these rules: 

- if you want to use config in the browser (i.e. a Client Component), you should access it using `DMNO_PUBLIC_CONFIG`
- if you want to use config on the server (i.e. a React Server Component or an API Route), you should access it via `DMNO_CONFIG`

By following these rules, you can ensure that your config is only exposed where you want it to be. And DMNO will provide your with appropriate feedback if you try to access it in the wrong place.

> INSERT SAMPLE CODE OR GIF

:::danger[Runtime vs. Buildtime]
The same rules still apply for runtime vs. buildtime. You can read more about that [here](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables#runtime-environment-variables).
:::











