// /Users/theo/dmno/dmno-reactivity/node_modules/.pnpm/jsonc-parser@3.2.1/node_modules/jsonc-parser/lib/esm/main.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("/node_modules/dmno/dist/index.js", {"importedNames":["getResolverCtx"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("/@fs/Users/theo/dmno/dmno-reactivity/node_modules/.pnpm/jsonc-parser@3.2.1/node_modules/jsonc-parser/lib/esm/impl/format.js");
const __vite_ssr_import_2__ = await __vite_ssr_import__("/@fs/Users/theo/dmno/dmno-reactivity/node_modules/.pnpm/jsonc-parser@3.2.1/node_modules/jsonc-parser/lib/esm/impl/edit.js");
const __vite_ssr_import_3__ = await __vite_ssr_import__("/@fs/Users/theo/dmno/dmno-reactivity/node_modules/.pnpm/jsonc-parser@3.2.1/node_modules/jsonc-parser/lib/esm/impl/scanner.js");
const __vite_ssr_import_4__ = await __vite_ssr_import__("/@fs/Users/theo/dmno/dmno-reactivity/node_modules/.pnpm/jsonc-parser@3.2.1/node_modules/jsonc-parser/lib/esm/impl/parser.js");

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';




/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
const createScanner = __vite_ssr_import_3__.createScanner;
Object.defineProperty(__vite_ssr_exports__, "createScanner", { enumerable: true, configurable: true, get(){ return createScanner }});
var ScanError;
Object.defineProperty(__vite_ssr_exports__, "ScanError", { enumerable: true, configurable: true, get(){ return ScanError }});
(function (ScanError) {
    ScanError[ScanError["None"] = 0] = "None";
    ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
    ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
    ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
    ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
    ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
Object.defineProperty(__vite_ssr_exports__, "SyntaxKind", { enumerable: true, configurable: true, get(){ return SyntaxKind }});
(function (SyntaxKind) {
    SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
    SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
    SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
    SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
    SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
    SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
    SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
    SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
    SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
    SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
    SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
    SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
    SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
    SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
    SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
    SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
    SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
const getLocation = __vite_ssr_import_4__.getLocation;
Object.defineProperty(__vite_ssr_exports__, "getLocation", { enumerable: true, configurable: true, get(){ return getLocation }});
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */
const parse = __vite_ssr_import_4__.parse;
Object.defineProperty(__vite_ssr_exports__, "parse", { enumerable: true, configurable: true, get(){ return parse }});
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
const parseTree = __vite_ssr_import_4__.parseTree;
Object.defineProperty(__vite_ssr_exports__, "parseTree", { enumerable: true, configurable: true, get(){ return parseTree }});
/**
 * Finds the node at the given path in a JSON DOM.
 */
const findNodeAtLocation = __vite_ssr_import_4__.findNodeAtLocation;
Object.defineProperty(__vite_ssr_exports__, "findNodeAtLocation", { enumerable: true, configurable: true, get(){ return findNodeAtLocation }});
/**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
const findNodeAtOffset = __vite_ssr_import_4__.findNodeAtOffset;
Object.defineProperty(__vite_ssr_exports__, "findNodeAtOffset", { enumerable: true, configurable: true, get(){ return findNodeAtOffset }});
/**
 * Gets the JSON path of the given JSON DOM node
 */
const getNodePath = __vite_ssr_import_4__.getNodePath;
Object.defineProperty(__vite_ssr_exports__, "getNodePath", { enumerable: true, configurable: true, get(){ return getNodePath }});
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
const getNodeValue = __vite_ssr_import_4__.getNodeValue;
Object.defineProperty(__vite_ssr_exports__, "getNodeValue", { enumerable: true, configurable: true, get(){ return getNodeValue }});
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
const visit = __vite_ssr_import_4__.visit;
Object.defineProperty(__vite_ssr_exports__, "visit", { enumerable: true, configurable: true, get(){ return visit }});
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
const stripComments = __vite_ssr_import_4__.stripComments;
Object.defineProperty(__vite_ssr_exports__, "stripComments", { enumerable: true, configurable: true, get(){ return stripComments }});
var ParseErrorCode;
Object.defineProperty(__vite_ssr_exports__, "ParseErrorCode", { enumerable: true, configurable: true, get(){ return ParseErrorCode }});
(function (ParseErrorCode) {
    ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
    ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
    ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
    ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
    ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
    ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
    ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
    ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
    ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
    ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
    ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
    ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
    ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
    ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
    ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
    ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));
function printParseErrorCode(code) {
    switch (code) {
        case 1 /* ParseErrorCode.InvalidSymbol */: return 'InvalidSymbol';
        case 2 /* ParseErrorCode.InvalidNumberFormat */: return 'InvalidNumberFormat';
        case 3 /* ParseErrorCode.PropertyNameExpected */: return 'PropertyNameExpected';
        case 4 /* ParseErrorCode.ValueExpected */: return 'ValueExpected';
        case 5 /* ParseErrorCode.ColonExpected */: return 'ColonExpected';
        case 6 /* ParseErrorCode.CommaExpected */: return 'CommaExpected';
        case 7 /* ParseErrorCode.CloseBraceExpected */: return 'CloseBraceExpected';
        case 8 /* ParseErrorCode.CloseBracketExpected */: return 'CloseBracketExpected';
        case 9 /* ParseErrorCode.EndOfFileExpected */: return 'EndOfFileExpected';
        case 10 /* ParseErrorCode.InvalidCommentToken */: return 'InvalidCommentToken';
        case 11 /* ParseErrorCode.UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';
        case 12 /* ParseErrorCode.UnexpectedEndOfString */: return 'UnexpectedEndOfString';
        case 13 /* ParseErrorCode.UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';
        case 14 /* ParseErrorCode.InvalidUnicode */: return 'InvalidUnicode';
        case 15 /* ParseErrorCode.InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';
        case 16 /* ParseErrorCode.InvalidCharacter */: return 'InvalidCharacter';
    }
    return '<unknown ParseErrorCode>';
}
Object.defineProperty(__vite_ssr_exports__, "printParseErrorCode", { enumerable: true, configurable: true, get(){ return printParseErrorCode }});
/**
 * Computes the edit operations needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */
function format(documentText, range, options) {
    return __vite_ssr_import_1__.format(documentText, range, options);
}
Object.defineProperty(__vite_ssr_exports__, "format", { enumerable: true, configurable: true, get(){ return format }});
/**
 * Computes the edit operations needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */
function modify(text, path, value, options) {
    return __vite_ssr_import_2__.setProperty(text, path, value, options);
}
Object.defineProperty(__vite_ssr_exports__, "modify", { enumerable: true, configurable: true, get(){ return modify }});
/**
 * Applies edits to an input string.
 * @param text The input text
 * @param edits Edit operations following the format described in {@linkcode EditResult}.
 * @returns The text with the applied edits.
 * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.
 */
function applyEdits(text, edits) {
    let sortedEdits = edits.slice(0).sort((a, b) => {
        const diff = a.offset - b.offset;
        if (diff === 0) {
            return a.length - b.length;
        }
        return diff;
    });
    let lastModifiedOffset = text.length;
    for (let i = sortedEdits.length - 1; i >= 0; i--) {
        let e = sortedEdits[i];
        if (e.offset + e.length <= lastModifiedOffset) {
            text = __vite_ssr_import_2__.applyEdit(text, e);
        }
        else {
            throw new Error('Overlapping edit');
        }
        lastModifiedOffset = e.offset;
    }
    return text;
}
Object.defineProperty(__vite_ssr_exports__, "applyEdits", { enumerable: true, configurable: true, get(){ return applyEdits }});
